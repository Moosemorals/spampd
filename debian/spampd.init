#!/bin/sh -e
#
# spampd	SpamPD is a spamdetection proxy daemon for SMTP and LMTP
#
#		This script was written for debian
#		by Sven Mueller <debian@incase.de>
#
# Version:	2.0  22-Aug-2005  debian@incase.de
#
### BEGIN INIT INFO
# Provides:		spampd
# Required-Start: 	$syslog $network $named $time
# Required-Stop:  	$syslog $network $named $time
# Should-Start: 	2 3 4 5
# Should-Stop:		1 6
# Short-Description:	spam detection proxy for SMTP and LMTP
# Description: 		SpamAssassin based perl proxy for SMTP and LMTP
#			which marks mails as spam/nonspam based on SpamAssassin
#			results
### END INIT INFO

PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin
DESC='spam checking proxy daemon'
NAME='spampd'
PROGRAM=/usr/sbin/spampd
#EXECUTABLE=`head -n 1 $PROGRAM | sed -e 's,^#![ 	]*/,/,;s,[ 	].*$,,'`
EXECUTABLE=/usr/bin/perl
PIDFILE=/var/run/spampd.pid

# set some important defaults (overridable via /etc/default/spampd)
USERID=spampd
GRPID=spampd

if [ "$EUID" !=  "0" ]; then
	echo "ERROR: Insufficient privileges. Retry as root" >&2
	exit 1
fi

if [ -f /etc/default/$NAME ]; then
	. /etc/default/$NAME
fi
	
istrue () {
    ANS=$(echo $1 | tr A-Z a-z)
    [ "$ANS" = 'yes' -o "$ANS" = 'true' -o "$ANS" = 'enable' -o "$ANS" = '1' ]
}

#
# find out wether to start spampd or not
#
istrue ${STARTSPAMPD} && STARTSPAMPD='true'

#
# Check wether the program is actually there
#
# return 5 as demanded by LSB 2.1 when program isn't installed.
[  -x $PROGRAM ] || exit 5

# 
# Calculate final commandline
#
S_TAGALL=''
S_AWL=''
S_LOCALONLY=''

istrue "$TAGALL" \
&& S_TAGALL='--tagall'

istrue "$AUTOWHITELIST" \
&& S_AWL='--auto-whitelist'

istrue "$LOCALONLY" \
&& S_LOCALONLY='--L'

istrue "$LOGINET" \
&& LOGTARGET="inet" \
|| LOGTARGET="unix"

ARGS="${S_LOCALONLY} ${S_AWL} ${S_TAGALL} "

[ -n "${LISTENPORT}" ] && ARGS="${ARGS} --port=${LISTENPORT}"

[ -n "${LISTENHOST}" ] && ARGS="${ARGS} --host=${LISTENHOST}"

[ -n "${DESTPORT}" ] && ARGS="${ARGS} --relayport=${DESTPORT}"

[ -n "${DESTHOST}" ] && ARGS="${ARGS} --relayhost=${DESTHOST}"

[ -n "${PIDFILE}" ] && ARGS="${ARGS} --pid=${PIDFILE}"

[ -n "${CHILDREN}" ] && ARGS="${ARGS} --children=${CHILDREN}"

[ -n "${USERID}" ] && ARGS="${ARGS} --user=${USERID}"

[ -n "${GRPID}" ] && ARGS="${ARGS} --group=${GRPID}"

[ -n "${LOGTARGET}" ] && ARGS="${ARGS} --logsock=${LOGTARGET}"

[ -n "${ADDOPTS}" ] && ARGS="${ARGS} ${ADDOPTS}"

function check_pid () {
	[ "$3" = "verbose" ] && VERBOSE=1
	if [ -f $2 ]; then
		kill -0 `cat $2` > /dev/null 2>&1
		RETVAL=$?
		if [ "$RETVAL" = "0" ]; then
			[ "$VERBOSE" ] && echo "$1 is running as `cat $2`"
			return 0
		else
			[ "$VERBOSE" ] && echo "PIDFILE $2 for $1 exists, but $1 is not running."
			rm $2
			return 1
		fi
	else
		[ "$VERBOSE" ] && echo "PIDFILE $2 for $1 doesn't exists."
		return 4
	fi
	return 3
}

case "$1" in
	start)
		if ! istrue "${STARTSPAMPD}"; then
			echo "Starting $DESC: $NAME (disabled in /etc/default/$NAME)."
			# returncode 5 demanded for this case by LSB 2.1
			exit 6
		fi
		echo -n "Starting $DESC: $NAME"
		# if spampd is already running, exit 0 as demanded by LSB 2.1
		# this also removes the PIDFILE if it exists but has no matching
		# process
		if check_pid $PROGRAM $PIDFILE ; then
			exit 0
		fi
		# if spampd is not installed, return 5 as demanded by LSB 2.1
		if [ ! -x $EXECUTABLE ]; then
			exit 5
		fi
		# start daemon
		start-stop-daemon --start --exec $EXECUTABLE \
			--startas $PROGRAM --pidfile $PIDFILE \
			--user $USERID --group $GRPID -- $ARGS
		if [ "$?" = '0' ]; then
			echo '.'
			exit 0
		else
			echo ''
			# LSB 2.1 says 7 should be returned when program
			# isn't running.
			exit 7
		fi
		;;
	stop)
		echo -n "Stopping $DESC: $NAME "
		set +e
		# if $PROGRAM is not running under PID given in
		# $PIDFILE, exit with 0 to be LSB compliant
		check_pid $PROGRAM $PIDFILE || exit 0
		if istrue "$STARTSPAMPD" ; then
			start-stop-daemon --stop --exec $EXECUTABLE \
				--pidfile $PIDFILE
		else
			start-stop-daemon --stop --exec $EXECUTABLE \
				--pidfile $PIDFILE > /dev/null 2>&1
		fi
		if [ "$?" = "0" ]; then
			echo '.'
			rm $PIDFILE
			exit 0
		else
			echo ''
			if ! check_pid $PROGRAM $PIDFILE ; then
				exit 0
			else
				# if we had not successfully stopped the
				# program, we can assume the user didn't
				# have sufficient privileges.
				exit 4
			fi
		fi
		;;
	status)
		check_pid $PROGRAM $PIDFILE verbose
		exit $?
		;;
	reload)
		echo "reload not implemented, try force-reload/restart instead"
		exit 3
		;;
	force-reload|try-restart)
		if check_pid $PROGRAM $PIDFILE ; then
			exec $0 restart
		else
			echo "$DESC is not running. Try '$0 start' to start it."
			# LSB 2.1 says that this should return success, anyhow.
			exit 0
		fi
		;;
	restart)
		if check_pid $PROGRAM $PIDFILE ; then
			$0 stop
		fi
		exec $0 start
		;;
	help)
		echo "Usage: $0 (start|stop|restart|try-restart|force-reload|status)"
		exit 0
		;;
	*)	echo "Usage: $0 (start|stop|restart|try-restart|force-reload|status|help)"
		exit 2
		;;

esac

echo "This point shouldn't be reached. Some weird thing happened"
exit 1
